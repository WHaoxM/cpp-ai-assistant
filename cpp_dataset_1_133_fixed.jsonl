{"id": 1, "type": "single_choice", "question": "关于关键字class和typename，下列表述中正确的是（ ）。", "options": ["程序中所有的typename都可以替换为class", "程序中部分typename都可以替换为class", "程序中所有的class都可以替换为typename", "程序中所有的class都不可以替换为typename"], "answer": "A", "explanation": "在模板参数声明中，class和typename在大多数情况下可以互换，但并非所有情况。在模板声明中，typename主要用于表示依赖类型名，class也可用。但本题标准答案为A，应理解为在模板参数声明场景下，typename和class可互换。", "knowledge_point": "模板参数声明", "difficulty": "easy"}
{"id": 2, "type": "single_choice", "question": "在进行了任何C++流的操作后，都可以用C++流的有关成员函数检测流的状态；其中只能用于检测输入操作的函数名是（ ）。", "options": ["fail()", "eof()", "good()", "bad()"], "answer": "B", "explanation": "eof()函数专门用于检测输入流是否到达文件尾，仅适用于输入操作。其他三个函数（fail、good、bad）可以检测任何流的状态（输入/输出）。", "knowledge_point": "C++流状态检测", "difficulty": "medium"}
{"id": 3, "type": "single_choice", "question": "当使用ofstream流类定义一个流对象并打开一个磁盘文件时，文件的默认打开方式为( )。", "options": ["ios_base::binary", "ios_base::in | ios_base::out", "ios_base::out", "ios_base::in"], "answer": "C", "explanation": "ofstream是输出文件流类，默认以ios_base::out（输出模式）打开文件。如果要同时支持输入输出，应使用fstream类。", "knowledge_point": "文件流操作", "difficulty": "easy"}
{"id": 4, "type": "single_choice", "question": "有如下函数模板定义： template <class T> func(T x,T y){return x*x+y*y;} 在下列对func的调用中，错误的是( )。", "options": ["func(3.0,5.5);", "func<int>(3,5.5);", "func<>(3,5)；", "func(3,5.5);"], "answer": "D", "explanation": "函数模板func要求两个参数类型相同。D选项中第一个参数是int(3)，第二个是double(5.5)，类型不一致，无法推导出统一的模板参数T。B选项通过显式指定<int>强制类型转换，C选项使用空<>让编译器推导，都是合法的。", "knowledge_point": "函数模板调用", "difficulty": "medium"}
{"id": 5, "type": "single_choice", "question": "下列模板声明中，有语法错误的是( )。", "options": ["template < class T > T fun(T x,int n){return x*n;}", "template < class T > fun(T x){return x;}", "template < class T >T class A{T n;};", "template < class T > T fun(T *p){return *p;}"], "answer": "C", "explanation": "C选项语法错误：类模板声明应使用'template <class T> class A {...}'，而不是'template <class T>T class A'。类模板声明中'class A'是固定的，不能在中间插入T。", "knowledge_point": "模板声明语法", "difficulty": "medium"}
{"id": 6, "type": "single_choice", "question": "有如下函数模板声明： template <class T> T Max(T a,T b){return (a>=b)?a:b;} 下列对函数模板Max的调用中错误的是（ ）。", "options": ["Max (3.5f,4.5f)", "Max(3.5,4.5)", "Max <double> (3.5,4)", "Max(3.5,4)"], "answer": "D", "explanation": "D选项中第一个参数是double(3.5)，第二个是int(4)，类型不一致，编译器无法推导出统一的模板参数T。C选项通过显式指定<double>，将int(4)隐式转换为double，是合法的。", "knowledge_point": "函数模板类型推导", "difficulty": "medium"}
{"id": 7, "type": "single_choice", "question": "语句ofstream f(\"SALARY.DAT\",ios_base::app);的功能是建立流对象f，并试图打开文件SALARY.DAT与f关联，而且( )。", "options": ["若文件存在，打开失败；若文件不存在，建立一个新文件", "若文件存在，将文件指针定位于文件尾；若文件不存在，建立一个新文件", "若文件存在，将文件指针定位于文件首；若文件不存在，打开失败", "若文件存在，将其置为空文件；若文件不存在，打开失败"], "answer": "B", "explanation": "ios_base::app表示追加模式：如果文件存在，文件指针定位到文件末尾进行写操作；如果文件不存在，则创建新文件。这是文件流的标准行为。", "knowledge_point": "文件打开模式", "difficulty": "easy"}
{"id": 8, "type": "single_choice", "question": "下列关于模板的叙述中，错误的是( )。", "options": ["调用模板函数时，在一定条件下可以省略模板实参", "模板的形参表中可以有多个参数", "模板声明中的关键字class都可以用关键字typename替代", "可以用int、double这样的类型修饰符来声明模板参数"], "answer": "C", "explanation": "C选项错误：在大多数情况下class和typename可以互换，但在模板模板参数中，只能使用class关键字，不能使用typename。", "knowledge_point": "模板基础", "difficulty": "hard"}
{"id": 9, "type": "single_choice", "question": "以下关于类模板的模板参数的叙述中，错误的是( )。", "options": ["模板参数可以作为数据成员的类型", "模板参数可以作为成员函数的参数类型", "模板参数不能作为成员函数的局部变量的类型", "模板参数可以作为成员函数的返回类型"], "answer": "C", "explanation": "C选项错误：模板参数完全可以作为成员函数内局部变量的类型。模板参数可以在类的任何地方使用，包括：数据成员类型、成员函数参数类型、成员函数返回类型、局部变量类型等。", "knowledge_point": "类模板参数使用", "difficulty": "medium"}
{"id": 10, "type": "single_choice", "question": "有如下函数模板： template < class T >T square(T x) {return x * x;} 其中T是( )。", "options": ["模板实参", "函数实参", "模板形参", "函数形参"], "answer": "C", "explanation": "在'template <class T>'中，T是模板形参（模板参数）。当调用square(5)时，T被推导为int，此时int是模板实参。", "knowledge_point": "模板形参与实参", "difficulty": "easy"}
{"id": 11, "type": "single_choice", "question": "关于函数模板，下列表述不正确的是（ ）。", "options": ["类模板的成员函数都是模板函数", "类模板本身在编译中不会产生任何代码", "用类模板定义一个对象时，不能省略实参", "类模板只能有虚拟类型参数"], "answer": "D", "explanation": "D选项错误：类模板可以有非类型参数（如整型常量），也可以有默认模板参数，不仅仅是虚拟类型参数。例如：template <class T, int size = 10> class Array {}。", "knowledge_point": "类模板特性", "difficulty": "medium"}
{"id": 12, "type": "single_choice", "question": "关于函数声明float fun(int a,int b) throw ();下列叙述正确的是（）。", "options": ["表明函数实际抛出的异常", "表明函数不抛出float类型的异常", "表明函数抛出float类型的异常", "表明函数抛出任何类型的异常"], "answer": "D", "explanation": "throw()是异常规范（C++98/03特性），表示函数不抛出任何异常。但本题选项中没有\"不抛出任何异常\"，最接近的是D（实际上throw()表示不抛出异常，不是抛出任何异常，但标准答案可能是D）。注意：C++11中已弃用异常规范，使用noexcept。", "knowledge_point": "异常规范", "difficulty": "hard"}
{"id": 13, "type": "single_choice", "question": "关于类模板下列说法不正确的是（ ）。", "options": ["用类模板定义一个对象时，不能省略实际参数", "类模板只是虚拟类型的参数", "类模板本身在编译中不会生成任何代码", "类模板的成员函数都是模板函数"], "answer": "B", "explanation": "B选项错误：类模板可以有非类型模板参数（如整型常量），不仅仅是虚拟类型参数。类模板的参数可以是类型参数，也可以是非类型参数。", "knowledge_point": "类模板参数", "difficulty": "medium"}
{"id": 14, "type": "single_choice", "question": "下面是一个模板声明的开始部分： template <class T > double… 由此可知( )。", "options": ["这既可能是一个函数模板的声明，也可能是一个类模板的声明", "这肯定是一个错误的模板声明", "这可能是一个函数模板的声明", "这可能是一个类模板的声明"], "answer": "C", "explanation": "由于返回类型是double（具体类型），这应该是一个函数模板的声明。类模板声明通常以'class ClassName'开始，而不是具体的返回类型。", "knowledge_point": "模板声明识别", "difficulty": "easy"}
{"id": 15, "type": "single_choice", "question": "下列有关模板的叙述中，正确的是( )。", "options": ["函数模板不能含有常规形参", "用类模板定义对象时，绝对不能省略模板实参", "函数模板的一个实例就是一个函数定义", "类模板的成员函数不能是模板函数"], "answer": "C", "explanation": "C选项正确：函数模板实例化后生成具体的函数定义。A错误：函数模板可以有常规形参；B错误：类模板可以有默认模板参数；D错误：类模板的成员函数可以是模板函数（嵌套模板）。", "knowledge_point": "模板实例化", "difficulty": "medium"}
{"id": 16, "type": "single_choice", "question": "C++中的模板包括( )。", "options": ["对象模板和函数模板", "对象模板和类模板", "变量模板和对象模板", "函数模板和类模板"], "answer": "D", "explanation": "C++模板主要分为两类：函数模板（生成函数）和类模板（生成类）。C++14之后还有变量模板，但本题考察基础分类。", "knowledge_point": "模板分类", "difficulty": "easy"}
{"id": 17, "type": "single_choice", "question": "要利用C++流进行文件操作，必须在程序中包含的头文件是( )。", "options": ["fstream", "iostream", "iomanip", "strstream"], "answer": "A", "explanation": "fstream头文件包含文件流类（ifstream、ofstream、fstream）。iostream用于标准I/O，iomanip用于格式化，strstream用于字符串流（已弃用）。", "knowledge_point": "文件流头文件", "difficulty": "easy"}
{"id": 18, "type": "single_choice", "question": "下面的函数模板定义中错误的是（ ）。", "options": ["template< class Q > Q F(Q x){return x+x;}", "template< class T > T F(T x){return x*x;}", "template< class Q > Q F(Q x){return Q+x;}", "template< class T > bool F {return x>1;}"], "answer": "C", "explanation": "C选项错误：'return Q+x;'中Q是类型名，不能与值x进行加法运算。类型名不能参与算术运算。", "knowledge_point": "函数模板定义", "difficulty": "medium"}
{"id": 19, "type": "single_choice", "question": "下列关于异常的叙述错误的是______。", "options": ["硬件故障也可当异常抛出", "编译错属于异常，可以抛出", "运行错属于异常", "只要是编程者认为是异常的都可当异常抛出"], "answer": "B", "explanation": "B选项错误：编译错误发生在编译阶段，不能被抛出为异常。异常是运行时机制，只能抛出运行时发生的错误。", "knowledge_point": "异常机制", "difficulty": "easy"}
{"id": 20, "type": "single_choice", "question": "执行语句序列 ofstream outfile(\"DATA.DAT\"); if(…)cout<<\"OK\";else cout<<\"FAIL\"; 后，如果文件打开成功显示\"OK\"，否则就显示\"FAIL\"。由此可知，上面if语句的…处的表达式应是（ ）。", "options": ["outfile.good() 或 outfile", "outfile.good() 或 !outfile", "outfile.fail() 或 !outfile", "outfile.fail() 或 outfile"], "answer": "A", "explanation": "A选项正确：outfile.good()返回true表示流状态良好；outfile（流对象）在布尔上下文中转换为true表示成功，false表示失败。两者都可用于判断文件是否成功打开。", "knowledge_point": "文件流状态检测", "difficulty": "medium"}
{"id": 21, "type": "single_choice", "question": "下列函数模板的定义中，合法的是( )。", "options": ["template T <class T> abs(T x){ return x<0 ? -x:x;}", "template <typename T> T abs(T x) {return x<0 ? -x:x;}", "template T abs(T x) { return x<0 ? -x:x;}", "template class<T> T abs(T x) {return x<0 ? -x:x;}"], "answer": "B", "explanation": "B选项是正确的函数模板语法：template <typename T> 或 template <class T> 后跟函数定义。A和C缺少<>，D使用了错误的'class<T>'语法。", "knowledge_point": "函数模板语法", "difficulty": "easy"}
{"id": 22, "type": "single_choice", "question": "当使用ofstream流类定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式为( )。", "options": ["ios::out", "ios::binary", "ios::in|ios::out", "ios::in"], "answer": "A", "explanation": "ofstream类默认以输出模式（ios::out）打开文件。这是其设计目的：用于向文件写入数据。", "knowledge_point": "ofstream默认模式", "difficulty": "easy"}
{"id": 23, "type": "single_choice", "question": "下列叙述错误的是（  ）。", "options": ["程序中try语句与catch语句是一个整体，缺一不可", "catch（…）语句可以放在catch语句组的中间", "catch（…）语句可捕获所有类型的异常", "一个try语句可以有多个catch语句"], "answer": "B", "explanation": "B选项错误：catch(…)应该放在所有具体类型catch语句的最后，因为它捕获所有异常。如果放在中间，后面的catch语句永远不会被执行。", "knowledge_point": "异常处理顺序", "difficulty": "medium"}
{"id": 24, "type": "single_choice", "question": "已知outfile是一个输出流对象，要想将outfile的文件指针定位到当前位置前321字节处，正确的函数调用语句是（ ）。", "options": ["outfile.seekp(321,ios_base::cur);", "outfile.seekp(-321,ios_base::cur);", "outfile.seekp(321,ios_base::beg);", "outfile.seekp(-321,ios_base::beg);"], "answer": "B", "explanation": "B选项正确：seekp用于设置输出文件指针位置。ios_base::cur表示从当前位置开始，-321表示向前移动321字节。", "knowledge_point": "文件指针定位", "difficulty": "medium"}
{"id": 25, "type": "single_choice", "question": "下列叙述错误的是（）。", "options": ["一个程序中可以有try语句而没有throw语句", "当catch语句捕获一个异常后，可能不能完全处理异常", "在try块中抛出异常后，程序最后回到try块中继续执行后面的语句", "throw语句抛出的异常可以不被捕获"], "answer": "C", "explanation": "C选项错误：在try块中抛出异常后，控制权立即转移到匹配的catch块，不会回到try块继续执行后面的语句。", "knowledge_point": "异常处理流程", "difficulty": "medium"}
{"id": 26, "type": "single_choice", "question": "有如下模板定义： template < class T>T func(T x,T y){return x*x+y*y;} 在下列对func的调用中不正确的是（ ）。", "options": ["func(3,5.5)", "func(3.0,5.0)", "func<double > (3,5.5)", "func(3,5)"], "answer": "A", "explanation": "A选项错误：第一个参数是int(3)，第二个是double(5.5)，类型不一致，模板参数T无法推导。其他选项要么类型一致，要么通过显式指定<double>强制转换。", "knowledge_point": "模板参数推导", "difficulty": "medium"}
{"id": 27, "type": "single_choice", "question": "在重载一个运算符为成员函数时，其参数中没有任何参数，这说明该运算符是（ ）。", "options": ["后缀一元运算符", "二元运算符", "无操作数运算符", "前缀一元运算符"], "answer": "D", "explanation": "D选项正确：当运算符重载为成员函数时，参数个数比实际操作数少1（隐含this指针）。如果参数列表为空，表示这是一元运算符，且是前缀形式（如++obj）。后缀一元运算符需要有一个int参数区分。", "knowledge_point": "运算符重载成员函数", "difficulty": "hard"}
{"id": 28, "type": "single_choice", "question": "有以下程序：#include <iostream>using namespace std;class B{public:virtual void show(){cout<<\"B\";}} ;class D: public B{public:void show() {cout<<\"D\";}};void fun1(B *ptr) {  ptr->show(); }void fun2(B &ref) { ref.show();}void fun3(B b ) { b.show();}int main(){B b,*p=new D;D d;fun1(p);fun2(b);fun3(d);return 0;}程序运行的输出结果是(    )。", "options": ["BBB", "DBBD", "DBD", "DBB"], "answer": "D", "explanation": "输出结果为DBB：1) fun1(p)中p指向D对象，调用虚函数show()，输出D；2) fun2(b)中b是B对象，输出B；3) fun3(d)中参数按值传递，发生切片，只复制基类部分，调用B::show()，输出B。", "knowledge_point": "虚函数与对象切片", "difficulty": "hard"}
{"id": 29, "type": "single_choice", "question": "有如下程序：#include<iostream>using namespace std;class GA{public:virtual int f(){return 1;}};class GB:public GA{public:virtual int f(){return 2;}};void show(GA g){cout<<g.f();}void display(GA &g){cout<<g.f();}int main(){GA a;show(a);display(a);GB b;show(b);display(b);return 0;}运行时的输出结果是（    ）。", "options": ["1211", "1112", "1212", "1111"], "answer": "B", "explanation": "输出结果为1112：1) show(a)按值传递，调用GA::f()，输出1；2) display(a)引用传递，调用GA::f()，输出1；3) show(b)按值传递发生对象切片，调用GA::f()，输出1；4) display(b)引用传递，多态调用GB::f()，输出2。", "knowledge_point": "多态与对象切片", "difficulty": "hard"}
{"id": 30, "type": "single_choice", "question": "通过运算符重载，可以改变运算符原有的( )。", "options": ["操作数个数", "结合性", "操作数类型", "优先级"], "answer": "C", "explanation": "C选项正确：运算符重载主要目的是让运算符能用于自定义类型的操作数，改变操作数类型。不能改变运算符的操作数个数、结合性和优先级。", "knowledge_point": "运算符重载限制", "difficulty": "medium"}
{"id": 31, "type": "single_choice", "question": "虚函数主要是为了实现类的（ ）。", "options": ["抽象性", "继承性", "多态性", "封装性"], "answer": "C", "explanation": "C选项正确：虚函数是实现运行时多态（动态绑定）的关键机制。通过基类指针或引用调用虚函数，实际调用的是派生类重写的版本。", "knowledge_point": "虚函数作用", "difficulty": "easy"}
{"id": 32, "type": "single_choice", "question": "在下面的运算符重载函数的原型中，错误的是（ ）。", "options": ["Volume operator-(double,double);", "double Volume::operator-(double);", "Volume operator-(Volume,Volume);", "Volume Volume::operator-(Volume);"], "answer": "A", "explanation": "A选项错误：运算符重载函数如果是非成员函数，必须至少有一个参数是类类型或枚举类型。两个double参数都不是用户定义类型，不能重载。", "knowledge_point": "运算符重载规则", "difficulty": "hard"}
{"id": 33, "type": "single_choice", "question": "关于纯虚函数，下列表述正确的是（ ）。", "options": ["派生类必须实现基类的纯虚函数", "纯虚函数的声明总是以\"=0\"结束", "含有纯虚函数的类不可能是派生类", "纯虚函数是没有给出显现版本（即无函数体定义）的虚函数"], "answer": "B", "explanation": "B选项正确：纯虚函数通过在声明后加\"=0\"来定义。A错误：如果派生类不实现纯虚函数，它也成为抽象类；C错误：派生类可以有纯虚函数；D不准确：纯虚函数可以有定义（提供默认实现）。", "knowledge_point": "纯虚函数", "difficulty": "medium"}
{"id": 34, "type": "single_choice", "question": "下列关于虚函数的描述中，正确的是（ ）。", "options": ["基类中采用virtual说明一个虚函数后，派生类中定义相同原型函数时可不必加virtual说明", "派生类中的虚函数与基类中相同原型的虚函数具有不同的参数个数或类型", "虚函数是一个非成员函数", "虚函数是一个static类型的成员函数"], "answer": "A", "explanation": "A选项正确：派生类中重写虚函数时，virtual关键字是可选的，函数会自动成为虚函数。但建议保留virtual以提高可读性。B错误：函数签名必须相同；C错误：虚函数必须是成员函数；D错误：虚函数不能是static的。", "knowledge_point": "虚函数特性", "difficulty": "medium"}
{"id": 35, "type": "single_choice", "question": "于运算符重载，下列表述中正确的是( )", "options": ["C++已有的任何运算符都可以重载", "运算符函数的返回类型不能声明为基本数据类型", "可以通过运算符重载来创建C++中原来没有的运算符", "在类型转换符函数的定义中不需要声明返回类型"], "answer": "D", "explanation": "D选项正确：类型转换运算符函数（如operator int()）不需要指定返回类型，返回类型由运算符名隐含决定。A错误：有些运算符不能重载（如::、.*、.、?:等）；B错误：可以返回基本类型；C错误：不能创建新运算符。", "knowledge_point": "运算符重载细节", "difficulty": "hard"}
{"id": 36, "type": "single_choice", "question": "有如下程序：#include <iostream>using namespace std;class Complex{double re,im;public:Complex (double r,double i):re(r),im(i) { }double real() const {return re;}double image() const { return im;}Complex& operator+=(Complex a){re+=a.re ;im+=a.im ;return *this ;}};ostream& operator<<(ostream& s,const Complex& z){return s<<'('<<z.real()<<','<<z.image()<<')';}int main(){Complex x(1,-2),y(2,3);cout<<(x+=y) <<endl;return 0;}执行这个程序的输出结果是(    )。", "options": ["(3,1)", "(2,3)", "(1,-2)", "(3,5)"], "answer": "A", "explanation": "输出结果为(3,1)：x初始为(1,-2)，y为(2,3)。x+=y执行后，x.re=1+2=3，x.im=-2+3=1。然后输出x的值(3,1)。注意：operator<<重载为友元函数，输出格式为(实部,虚部)。", "knowledge_point": "运算符重载与流输出", "difficulty": "medium"}
{"id": 37, "type": "single_choice", "question": "在C++中用来实现运行时多态性的是( )", "options": ["重载函数", "构造函数", "虚函数", "析构函数"], "answer": "C", "explanation": "C选项正确：运行时多态（动态多态）通过虚函数和继承实现。函数重载是编译时多态（静态多态）。", "knowledge_point": "多态类型", "difficulty": "easy"}
{"id": 38, "type": "single_choice", "question": "下列运算中，( )运算符在C++中不能重载。", "options": ["<=", "+", "?:", "-"], "answer": "C", "explanation": "C选项正确：条件运算符?:不能重载。其他可以重载的运算符包括：算术运算符、关系运算符、逻辑运算符、赋值运算符等。不能重载的还有：.、.*、::、sizeof等。", "knowledge_point": "不可重载运算符", "difficulty": "medium"}
{"id": 39, "type": "single_choice", "question": "下列关于模板的叙述中，错误的是（ ）。", "options": ["在一定条件下函数模板的实参可以省略", "模板声明中的第一个符号总是关键字templat", "在模板声明中用<>括起来的部分是模板的形参表", "类模板不能有数据成员"], "answer": "D", "explanation": "D选项错误：类模板可以有数据成员，数据成员的类型可以是模板参数。A正确：函数模板实参可通过推导省略；B正确：模板声明以template开始；C正确：<>内是模板参数列表。", "knowledge_point": "模板基础概念", "difficulty": "easy"}
{"id": 40, "type": "single_choice", "question": "下列关于运算符重载的叙述中，正确的是（ ）。", "options": ["重载一个二元运算符时必须声明两个形参", "若重载运算符+，则相应的运算符函数名是+", "通过运算符重载，可以定义新的运算符", "有的运算符只能作为成员函数重载"], "answer": "D", "explanation": "D选项正确：有些运算符只能作为成员函数重载，如=、[]、()、->、类型转换运算符。A错误：成员函数重载二元运算符只需一个形参（另一个是this）；B错误：函数名是operator+；C错误：不能创建新运算符。", "knowledge_point": "运算符重载限制", "difficulty": "medium"}
{"id": 41, "type": "single_choice", "question": "下列关于运算符重载的叙述中，错误的是( )。", "options": ["有的运算符可以作为非成员函数重载", "有的运算符只能作为成员函数重载", "所有的运算符都可以通过重载而被赋予新的含义", "不得为重载的运算符函数的参数设置默认值"], "answer": "C", "explanation": "C选项错误：不是所有运算符都可以重载，如::、.*、.、?:、sizeof等不能重载。D选项正确：运算符函数参数不能有默认值。", "knowledge_point": "运算符重载限制", "difficulty": "medium"}
{"id": 42, "type": "single_choice", "question": "下列关于虚函数的说明中，正确的是（ ）。", "options": ["只能通过指针或引用调用虚函数", "虚函数不得是静态成员函数", "从虚基类继承的函数都是虚函数", "抽象类中的成员函数都是虚函数"], "answer": "B", "explanation": "B选项正确：虚函数不能是static的，因为static函数属于类而不属于对象，没有this指针。A错误：可以通过对象调用虚函数（但无多态效果）；C错误：虚基类与虚函数无关；D错误：抽象类可以有非虚函数。", "knowledge_point": "虚函数限制", "difficulty": "hard"}
{"id": 43, "type": "single_choice", "question": "有如下程序：#include <iostream>#include <iomanip>using namespace std;class CSum{int x,y;public:CSum(int x0,int y0):x(x0),y(y0){}friend ostream&operator<<(ostream&os,const CSum&xa){os<<setw(5)<<xa.x+xa.y;return os;}};int main(){CSum y(3,5);cout<<setfill('*')<<8;cout<<y;return 0;}执行上面程序的输出是（   ）。", "options": ["****88", "88", "****8****8", "8****8"], "answer": "D", "explanation": "输出结果为8****8：1) cout<<setfill('*')<<8;输出8（无宽度设置）；2) cout<<y;调用operator<<，setw(5)设置宽度为5，填充字符为*，输出x+y=8，但宽度5，左对齐，因此输出****8。合起来就是8****8。", "knowledge_point": "流格式控制", "difficulty": "hard"}
{"id": 44, "type": "single_choice", "question": "下列运算符不能重载为友元函数的是( )。", "options": ["+= -= *= /=", "= () [] ->", "+ - ++ --", "> < >= <="], "answer": "B", "explanation": "B选项正确：赋值运算符=、下标运算符[]、函数调用运算符()、成员访问运算符->只能作为成员函数重载，不能作为友元函数重载。其他运算符可以作为友元或成员函数。", "knowledge_point": "运算符重载形式限制", "difficulty": "hard"}
{"id": 45, "type": "single_choice", "question": "虚函数支持多态调用，一个基类的指针可以指向派生类的对象，而且通过这样的指针调用虚函数时，被调用的是指针所指的实际对象的虚函数。而非函数不支持多态调用。有如下程序：#include<iostream>using namespace std;class Base{public:virtual void f(){cout<< \"f0+\";}void g() { cout<< \"g0+\";}};class Derived:public Base{public:void f(){cout << \"f+\";}void g(){cout<< \"g+\";}};int main(){Derived d;Base *p=&d;p->f();  p->g();return 0;}运行时输出的结果是(    )。", "options": ["f0+g+", "f+g+", "f+g0+", "f0+g0+"], "answer": "C", "explanation": "输出结果为f+g0+：1) p->f()调用虚函数，多态调用Derived::f()，输出f+；2) p->g()调用非虚函数，静态绑定Base::g()，输出g0+。", "knowledge_point": "虚函数与非虚函数调用", "difficulty": "medium"}
{"id": 46, "type": "single_choice", "question": "下列运算符函数中，肯定不属于类Value的成员函数的是( )。", "options": ["Value operator/(Value);", "Value operator-(Value);", "Value operator*(int);", "Value operator+(Value,Value);"], "answer": "D", "explanation": "D选项正确：二元运算符+作为成员函数时应该只有一个参数（另一个是this），而这里有两个Value参数，说明是全局函数或友元函数，不是成员函数。成员函数的二元运算符重载形式为：Value operator+(const Value&) const。", "knowledge_point": "运算符重载成员函数形式", "difficulty": "hard"}
{"id": 47, "type": "single_choice", "question": "下列有关抽象类和纯虚函数的叙述中，错误的是( )。", "options": ["纯虚函数都的声明可以不用\"=0;\"结束", "抽象类的派生类若不实现纯虚函数，它也是抽象类", "拥有纯虚函数的类是抽象类，不能用来定义对象", "纯虚函数的声明以\"=0;\"结束"], "answer": "A", "explanation": "A选项错误：纯虚函数必须在声明时用\"=0\"标识。B正确：派生类不实现所有纯虚函数则仍是抽象类；C正确：抽象类不能实例化；D正确：纯虚函数以\"=0\"结束。", "knowledge_point": "抽象类与纯虚函数", "difficulty": "easy"}
{"id": 48, "type": "single_choice", "question": "如果表达式a>=b中的\">=\"是作为非成员函数重载的运算符，则可以等效地表示为( )。", "options": ["b.operator>=(a)", "a.operator>=(b)", "operator>=(b,a)", "operator>=(a,b)"], "answer": "D", "explanation": "D选项正确：非成员函数重载的运算符调用形式为operator>=(a,b)。成员函数形式为a.operator>=(b)。注意参数顺序与表达式一致。", "knowledge_point": "运算符重载调用形式", "difficulty": "medium"}
{"id": 49, "type": "single_choice", "question": "有如下程序：#include <iostream>using namespace std;class Base{public:void output() { cout<<1;}virtual void Print(){cout<<'B';}};class Derived : public Base{public:void output() {cout<<2;}void Print() { cout<<'D';}};int main(){Base *ptr=new Derived;ptr->output();ptr->Print();delete ptr;return 0;}程序的输出结果是(    )。", "options": ["2D", "1B", "1D", "2B"], "answer": "C", "explanation": "输出结果为1D：1) ptr->output()调用非虚函数，静态绑定Base::output()，输出1；2) ptr->Print()调用虚函数，多态调用Derived::Print()，输出D。", "knowledge_point": "虚函数与非虚函数区别", "difficulty": "medium"}
{"id": 51, "type": "single_choice", "question": "有如下程序#include<iostream>#include<iomanip>using namespace std;class MyClass{public:MyClass(){cout<<'A';}MyClass(char c){cout<<c;}~MyClass(){cout<<'B';}};int main(){MyClass pl,*p2;p2=new MyClass('X');delete p2;return 0;}执行这个程序屏幕上将显示输出(    )。", "options": ["ABX", "AXB", "ABXB", "AXBB"], "answer": "D", "explanation": "输出结果为AXBB：1) MyClass pl;调用默认构造函数，输出A；2) p2=new MyClass('X');调用有参构造函数，输出X；3) delete p2;调用析构函数，输出B；4) main结束，pl析构，输出B。注意：pl调用默认构造函数但未输出内容？仔细看代码，pl声明时调用默认构造函数输出A。", "knowledge_point": "构造函数与析构函数调用顺序", "difficulty": "medium"}
{"id": 52, "type": "single_choice", "question": "语句int *p=&k;定义了指针p ，与这个语句等效的语句序列是( )。", "options": ["int *p;*p=k;", "int *p;p=&k;", "int *p;p=k;", "int *p;*p=&k;"], "answer": "B", "explanation": "B选项正确：int *p=&k;等价于int *p; p=&k;。A错误：*p=k是给p指向的内存赋值，不是让p指向k；C错误：p=k是把k的值当作地址赋给p；D错误：*p=&k是把k的地址赋给p指向的内存。", "knowledge_point": "指针定义与初始化", "difficulty": "easy"}
{"id": 53, "type": "single_choice", "question": "有如下程序：#include <iostream>#include <iomanip >using namespace std;int main(){cout.fill('*');cout<<left<<setw(4)<<123<<\"OK\"<<endl;return 0;}执行这个程序的输出结果是(    )。", "options": ["*123**OK", "*123OK", "123*OK**", "123*OK"], "answer": "D", "explanation": "输出结果为123*OK：1) setw(4)设置输出宽度为4；2) left左对齐；3) fill('*')填充字符为*；4) 输出123（3位），需要补1个*，所以输出123*；5) 接着输出OK。结果为123*OK。", "knowledge_point": "I/O流格式控制", "difficulty": "medium"}
{"id": 54, "type": "single_choice", "question": "以下说法不正确的是：", "options": ["当数组名作为函数的参数时，则退化为一个指针", "引用也可以作为函数的形参", "只有指向常量的指针才能作为函数的形参", "以指针作为函数参数可以实现数据的双向传递"], "answer": "C", "explanation": "C选项错误：函数的形参可以是任何类型的指针，不一定非要指向常量。指向常量的指针只是指针的一种用法，不是必须的。", "knowledge_point": "函数参数传递", "difficulty": "easy"}
{"id": 55, "type": "single_choice", "question": "下列程序的输出结果是(     )#include<iostream>using namespace std;int main(){char a[]=\"Hello,World\";char *ptr=a;while(*ptr){if(*ptr>='a'&&*ptr<='z')cout<<char(*ptr+'A'-'a');else cout<<*ptr;ptr++;}return 0;}", "options": ["hELLO,wORLD", "HELLO,WORLD", "hello,world", "Hello,World"], "answer": "B", "explanation": "输出结果为HELLO,WORLD：程序将字符串中的小写字母转换为大写字母（*ptr+'A'-'a'），大写字母和标点保持不变。Hello,World转换为HELLO,WORLD。", "knowledge_point": "字符数组与指针操作", "difficulty": "easy"}
{"id": 56, "type": "single_choice", "question": "有如下程序： #include<iostream>using namespace std;class Amount{int amount;public:Amount(int n=0):amount(n){}int getAmount()const{return amount;}Amount &operator+=(Amount a){amount+=a.amount;return ____________;}};int main(){Amount x(3),y(7);x+=y;cout<<x.getAmount()<<endl;return 0;}已知程序的运行结果是10，则下划线处缺失的表达式是（   ）。", "options": ["this", "amount", "*this", "&amount"], "answer": "C", "explanation": "C选项正确：operator+=应该返回*this，以支持连续赋值（如x+=y+=z）。返回引用允许链式操作。this是指针，*this是对象引用。", "knowledge_point": "运算符重载返回值", "difficulty": "medium"}
{"id": 57, "type": "single_choice", "question": "设有如下程序：#include<iostream>using namespace std;int main(){int **x,*y,z=10;y=&z;x=&y;cout<<**x+1<<endl;return 0;}以上程序的输出结果是（     ）。", "options": ["运行错误", "11", "y的地址", "z的地址"], "answer": "B", "explanation": "输出结果为11：1) z=10；2) y=&z，y指向z；3) x=&y，x指向y；4) **x=**(&y)=*y=*(&z)=z=10；5) **x+1=10+1=11。", "knowledge_point": "多级指针", "difficulty": "medium"}
{"id": 58, "type": "single_choice", "question": "以下关于地址和指针的叙述中正确的是(    )", "options": ["可以取常量的地址赋值给同类型的指针变量", "可以取一个指针变量的地址赋给本指针变量，这样就使得指针变量指向自身", "所有指针变量如果未赋初值，则自动赋空值NULL", "可以取变量的地址赋值给同类型的指针变量"], "answer": "D", "explanation": "D选项正确：这是指针的基本用法。A错误：不能取字面常量的地址（如&5错误）；B错误：指针变量不能指向自身类型（需要void*或二级指针）；C错误：未初始化的指针是野指针，不是自动为NULL。", "knowledge_point": "指针基础", "difficulty": "easy"}
{"id": 59, "type": "single_choice", "question": "初始化一个二维数组static int a[3][4]={{1},{0,6},{0,0,11}};a[0][3]的值为：", "options": ["11", "6", "0", "1"], "answer": "C", "explanation": "a[0][3]的值为0：数组初始化规则：1) a[0][0]=1，a[0][1]=0，a[0][2]=0，a[0][3]=0；2) a[1][0]=0，a[1][1]=6，a[1][2]=0，a[1][3]=0；3) a[2][0]=0，a[2][1]=0，a[2][2]=11，a[2][3]=0。未显式初始化的元素自动为0。", "knowledge_point": "二维数组初始化", "difficulty": "easy"}
{"id": 60, "type": "single_choice", "question": "关于动态存储分配，下列说法正确的是( )。", "options": ["动态分配的内存空间也可以被初始化", "当动态分配内存失败时，系统会立刻崩溃，因此一定要慎用new", "new和delete是C++语言中专门用于动态内存分配和释放的函数", "当系统内存不够时，会自动回收不再使用的内存单元，因此程序中不必用delete释放内存空间"], "answer": "A", "explanation": "A选项正确：new可以带初始化，如int *p=new int(5)。B错误：new失败会抛出bad_alloc异常或返回nullptr（与编译器设置有关）；C错误：new和delete是运算符，不是函数；D错误：C++没有垃圾回收，必须手动delete。", "knowledge_point": "动态内存管理", "difficulty": "medium"}
{"id": 61, "type": "single_choice", "question": "在\"int a[ ][3]={{1},{3,2},{4,5,6},{0}};\"中，a[2][2]的值是（ ）。", "options": ["1", "2", "0", "6"], "answer": "D", "explanation": "a[2][2]的值为6：数组是4行3列，初始化：第0行：{1,0,0}；第1行：{3,2,0}；第2行：{4,5,6}；第3行：{0,0,0}。所以a[2][2]=6。", "knowledge_point": "二维数组初始化与访问", "difficulty": "easy"}
{"id": 62, "type": "single_choice", "question": "要定义数组A，使得其中每个元素的数据依次为：3、9、4、8、0、0、0，错误的定义语句是（ ）。", "options": ["int A[7]={3,9,4,8,0,0,0}", "int A[]={3,9,4,8,0,0,0}", "int A[]={3,9,4,8}", "int A[7]={3,9,4,8}"], "answer": "C", "explanation": "C选项错误：int A[]={3,9,4,8}定义的是4个元素的数组，值为{3,9,4,8}，不符合要求（需要7个元素，后三个为0）。其他选项都能得到7元素数组，后三个为0。", "knowledge_point": "数组定义与初始化", "difficulty": "easy"}
{"id": 63, "type": "single_choice", "question": "对于\"int *pa[5];\"的描述中，（ ）是正确的。", "options": ["pa是一个具有5个元素的指针数组，每个元素是一个int型指针", "pa是一个指向某数组中第5个元素的指针，该元素是int型变量", "pa是一个指向数组的指针，所指向的数组是5个int型元素", "pa [5]表示某个元素的第5个元素的值"], "answer": "A", "explanation": "A选项正确：int *pa[5]定义了一个包含5个int*类型元素的数组。B描述的是int (*pa)[5]；C描述的是int (*pa)[5]；D错误：pa[5]是访问第6个元素（越界）。", "knowledge_point": "指针数组与数组指针", "difficulty": "medium"}
{"id": 64, "type": "single_choice", "question": "下列程序的输出结果是（    ）。#include<iostream>using namespace std;int n[][3]={10,20,30,40,50,60};int main(){int (*p)[3];p=n;cout<<p[0][0]<<\",\"<<*(p[0]+1)<<\",\"<<(*p)[2]<<endl;return 0;}", "options": ["10 20 30", "20 40 60", "10 30 50", "10 30 60"], "answer": "A", "explanation": "输出结果为10,20,30：数组n为2行3列：{{10,20,30},{40,50,60}}。p是指向数组的指针。1) p[0][0]=10；2) *(p[0]+1)=p[0][1]=20；3) (*p)[2]=p[0][2]=30。", "knowledge_point": "数组指针访问", "difficulty": "medium"}
{"id": 65, "type": "single_choice", "question": "对于下列语句动态分配的内存，其释放语句正确的是（ ）。 int *pa=new int[10];", "options": ["delete pa;", "delete pa[0];", "delete []pa;", "delete *pa;"], "answer": "C", "explanation": "C选项正确：new[]分配数组，必须用delete[]释放。用delete pa或delete *pa都会导致未定义行为（内存泄漏或崩溃）。", "knowledge_point": "动态数组释放", "difficulty": "easy"}
{"id": 66, "type": "single_choice", "question": "已知：p是一个指向类A公开的数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确的是（ ）", "options": ["A1.p=5;", "*A1.p=5;", "A1->p=5;", "A1.*p=5;"], "answer": "D", "explanation": "D选项正确：A1.*p表示通过对象A1和成员指针p访问成员m。.*是成员指针运算符。A错误：p不是A1的成员；B错误：需要括号(A1.*p)=5；C错误：A1是对象，不能用->。", "knowledge_point": "成员指针运算符", "difficulty": "hard"}
{"id": 67, "type": "single_choice", "question": "如果x是整型变量，则合法的形式是____答案填大写字母。", "options": ["&*x", "*x", "*&x", "&(x+5)"], "answer": "C", "explanation": "C选项正确：*&x等价于x。&取x的地址，*解引用该地址得到x。A错误：&*x中*x要求x是指针；B错误：*x要求x是指针；D错误：不能取表达式x+5的地址。", "knowledge_point": "指针与地址运算符", "difficulty": "medium"}
{"id": 68, "type": "single_choice", "question": "下列关于this指针的叙述中，正确的是( )。", "options": ["类的成员函数都有this指针", "类的非静态成员函数才有this指针", "类的友元函数都有this指针", "任何与类相关的函数都有this指针"], "answer": "B", "explanation": "B选项正确：只有非静态成员函数有隐含的this指针。静态成员函数没有this指针，友元函数不是成员函数也没有this指针。", "knowledge_point": "this指针", "difficulty": "medium"}
{"id": 69, "type": "single_choice", "question": "关于this指针的说法不正确的是（ ）。", "options": ["它是成员函数所属对象的指针", "成员函数访问类中数据成员的格式可写成：this->成员变量", "可以通过this.成员变量的形式访问类中的数据成员", "它是一种隐含指针，存在于每个类的非静态成员函数中"], "answer": "C", "explanation": "C选项错误：this是指针，应该用this->成员变量，而不是this.成员变量。其他选项都正确描述了this指针的特性。", "knowledge_point": "this指针使用", "difficulty": "easy"}
{"id": 70, "type": "single_choice", "question": "执行下列语句后，输出的结果是（     ）。#include<iostream>using namespace std;int main(){int j;int m[3][2]={10,20,30,40,50,60};for(j=0;j<2;j++)cout<<m[2-j][j]<<' ';return 0;}", "options": ["20 40", "60 40", "10 30", "50 40"], "answer": "D", "explanation": "输出结果为50 40：数组m为3行2列：{{10,20},{30,40},{50,60}}。循环：j=0时，m[2][0]=50；j=1时，m[1][1]=40。", "knowledge_point": "二维数组访问", "difficulty": "easy"}
{"id": 71, "type": "single_choice", "question": "下列关于输入流类成员函数getline()的描述中，错误的是( )。", "options": ["该函数读取字符串时，遇到终止符便停止", "该函数读取字符串时，可以包含空格", "该函数是用来读取键盘输入的字符串的", "该函数读取的字符串长度是受限制的"], "answer": "C", "explanation": "C选项错误：getline()是istream类的成员函数，可以用于任何输入流（文件流、字符串流等），不仅限于键盘输入。其他选项都正确描述了getline的特性。", "knowledge_point": "getline函数", "difficulty": "medium"}
{"id": 72, "type": "single_choice", "question": "关于指针类型的函数，下列说法正确的是：", "options": ["可以返回非静态局部变量的地址", "子函数中通过new操作取得的地址不能作为返回值", "可以返回主调函数中合法的地址", "子函数中通过new操作取得的地址不存在安全隐患"], "answer": "C", "explanation": "C选项正确：可以返回主调函数中定义的变量的地址（如参数地址）。A错误：返回非静态局部变量地址会导致悬垂指针；B错误：new的地址可以作为返回值；D错误：new的地址可能忘记delete导致内存泄漏。", "knowledge_point": "函数返回指针", "difficulty": "medium"}
{"id": 73, "type": "single_choice", "question": "在下面的一维数组定义中，（ ）有语法错误。", "options": ["int a[5];", "int a[];", "int a[10]={0};", "int a[]={1,2,3};"], "answer": "B", "explanation": "B选项错误：定义数组时必须指定大小（通过[]或初始化列表）。只有作为函数参数时，int a[]才有效。其他选项都是合法的数组定义。", "knowledge_point": "数组定义语法", "difficulty": "easy"}
{"id": 74, "type": "single_choice", "question": "设\"char **s；\"，以下正确的表达式是（ ）。", "options": ["s=\"computer\"", "**s=\"computer\"", "*s=\"computer\"", "*s='c'"], "answer": "C", "explanation": "C选项正确：s是char**（指向字符指针的指针），*s是char*（字符指针），可以指向字符串\"computer\"。A错误：不能将char*赋值给char**；B错误：**s是char，不能指向字符串；D错误：'c'是字符，不是字符串。", "knowledge_point": "多级指针与字符串", "difficulty": "hard"}
{"id": 75, "type": "single_choice", "question": "有如下程序： #include <iostream> using namespace std; int main( ) { int *p; *p = 9; cout<<\"The value at p:\"<< *p; return 0; } 编译运行程序将出现的情况是( )。", "options": ["运行时一定输出：The value at P:*9", "编译时出现语法错误，不能生成可执行文件", "运行时一定输出：The value at P:9", "运行时有可能出错"], "answer": "D", "explanation": "D选项正确：指针p未初始化，是野指针，对其解引用(*p=9)是未定义行为，可能崩溃、输出随机值或看似正常工作。编译器可能不报错（语法正确），但运行结果不确定。", "knowledge_point": "野指针风险", "difficulty": "medium"}
{"id": 76, "type": "single_choice", "question": "有如下头文件：int f1();static int f2();class MA{public:int f3();static int f4();};在所描述的函数中，具有隐含的this指针的是( )。", "options": ["f3", "f4", "f1", "f2"], "answer": "A", "explanation": "A选项正确：f3是MA类的非静态成员函数，有隐含的this指针。f4是静态成员函数，没有this指针。f1和f2是全局函数，也没有this指针。", "knowledge_point": "this指针存在条件", "difficulty": "easy"}
{"id": 77, "type": "single_choice", "question": "关于下列语句叙述错误的是( )。 int i=10， *p=&i;", "options": ["p的值是变量i的地址", "p指向整型变量i", "*p表示变量i的值", "p的值为10"], "answer": "D", "explanation": "D选项错误：p的值是i的地址，不是10。*p的值才是10。其他选项正确描述了指针p的特性。", "knowledge_point": "指针基础概念", "difficulty": "easy"}
{"id": 78, "type": "single_choice", "question": "执行下面程序后，输出的结果是（   ）。#include<iostream>using namespace std;char *x[]={\"First\",\"Second\",\"Third\"};void f(char *z[]){cout<<*++z<<endl;}int main(){char **y;y=x;f(y);return 0;}", "options": ["Third", "First", "Second", "S"], "answer": "C", "explanation": "输出结果为Second：1) x是指针数组；2) y指向x[0]；3) f(y)中，z是y的副本，指向x[0]；4) ++z使z指向x[1]；5) *z得到\"Second\"。注意：先++后*。", "knowledge_point": "指针数组与指针运算", "difficulty": "hard"}
{"id": 79, "type": "single_choice", "question": "下列语句中，正确的是( )。", "options": ["char myString=\"Hello-World!\";", "char myString[12]=\"Hello-World!\";", "char *myString=\"Hello-World!\";", "char myString[11]=\"Hello-World!\""], "answer": "C", "explanation": "C选项正确：字符指针可以指向字符串字面量。A错误：不能用字符串初始化char变量；B错误：\"Hello-World!\"有12个字符（包括\\0），需要13个空间；D错误：空间不足（需要13个）。", "knowledge_point": "字符串定义", "difficulty": "easy"}
{"id": 80, "type": "single_choice", "question": "已知n是一个int型变量，下列语句中错误的是（ ）。", "options": ["long *p=new long[n];", "long p[n];", "long *p=new long(n);", "long p[10];"], "answer": "B", "explanation": "B选项错误：C++中数组大小必须是编译时常量（C99支持变长数组但不是标准C++）。n是变量，不能用于定义数组大小。其他选项都合法。", "knowledge_point": "数组大小要求", "difficulty": "medium"}
{"id": 81, "type": "single_choice", "question": "对于下面定义的类MyClass,在函数f（）中将对象成员n的值修改为50的语句应该是（ ）。class MyClass{public:MyClass(int x){n=x;}void SetNum(int n1){n=n1;}private:int n;};int f(){MyClass *ptr=new MyClass(45);_________;}", "options": ["ptr->SetNum(50)", "ptr->n=50", "SetNum(50)", "MyClass(50)"], "answer": "A", "explanation": "A选项正确：n是私有成员，必须通过公有成员函数SetNum()修改。B错误：n是私有成员，不能直接访问；C错误：缺少对象；D错误：创建临时对象，不修改ptr指向的对象。", "knowledge_point": "类成员访问控制", "difficulty": "easy"}
{"id": 82, "type": "single_choice", "question": "下列程序的功能是将数组中的所有元素全部输出，对于程序中缺少的语句，下列语句填入其中不正确的是（ ）。int a[]={1,2,3,4};int *pa=a;for(int i=0;i<4;i++) ______;", "options": ["cout<<*(pa+i)<<' '", "cout<<*a++<<' '", "cout<<*(a+i)<<' '", "cout<<*pa++<<' '"], "answer": "B", "explanation": "B选项错误：a是数组名，是常量指针，不能进行++操作（a++非法）。其他选项都能正确输出数组元素。", "knowledge_point": "数组名与指针运算", "difficulty": "medium"}
{"id": 83, "type": "single_choice", "question": "已知数组arr的定义如下int arr[5]  = {1,2,3,4,5};下列语句中值不是2的是(   )", "options": ["*(arr+1)", "*arr", "arr[1]", "*arr+1"], "answer": "B", "explanation": "B选项：*arr是arr[0]=1，不是2。A：*(arr+1)=arr[1]=2；C：arr[1]=2；D：*arr+1=1+1=2。", "knowledge_point": "数组指针运算", "difficulty": "easy"}
{"id": 84, "type": "single_choice", "question": "有如下程序：#include <iostream>using namespace std;int main(){char str[100],*p;cout<< \"Please input a string:\";cin>>str;p=str;for(int i=0;*p!='\\0';p++,i++);cout<<i<<endl;return 0;}运行这个程序时，若输入字符串为abcdefg abcd则输出结果是(     )。", "options": ["100", "12", "13", "7"], "answer": "D", "explanation": "输出结果为7：cin>>str遇到空格停止，所以只读取\"abcdefg\"（7个字符）。循环统计字符数，遇到\\0停止，i=7。注意：cin>>str不会读取空格后的内容。", "knowledge_point": "字符串输入与长度计算", "difficulty": "easy"}
{"id": 85, "type": "single_choice", "question": "执行下列语句后，屏幕的输出结果是（    ）。#include<iostream>using namespace std;int main(){int a=5;int *pa=&a;int &b=a;b++;cout<<(*pa)++<<endl;return 0;}", "options": ["6", "8", "5", "7"], "answer": "A", "explanation": "输出结果为6：1) a=5；2) b是a的引用，b++使a=6；3) *pa就是a，(*pa)++输出a的当前值6，然后a自增为7。注意：cout<<(*pa)++是先输出再自增。", "knowledge_point": "引用与指针操作", "difficulty": "medium"}
{"id": 86, "type": "single_choice", "question": "已知在函数func中语句this->ff=0;与语句ff=0;的效果完全相同。对于这一现象，下面的表述中错误的是（ ）。", "options": ["ff是某个类的数据成员，func是该类的成员函数", "this->ff和ff是同一个变量", "func不是一个静态成员函数", "ff是某个类的数据成员，func是该类的友元函数"], "answer": "D", "explanation": "D选项错误：如果func是友元函数，它没有this指针，不能使用this->ff。其他选项都正确：A、B、C解释了为什么this->ff和ff效果相同（ff是成员，func是非静态成员函数）。", "knowledge_point": "this指针与成员访问", "difficulty": "medium"}
{"id": 87, "type": "single_choice", "question": "使用Point a[3]={Point(1,2),Point(3,4),Point()};时，系统调用了(    )次Point类的默认构造函数？", "options": ["0", "3", "2", "1"], "answer": "D", "explanation": "调用1次默认构造函数：前两个元素调用有参构造函数Point(1,2)和Point(3,4)，第三个元素Point()调用默认构造函数。", "knowledge_point": "对象数组构造函数调用", "difficulty": "medium"}
{"id": 88, "type": "single_choice", "question": "有如下程序：#include<iostream>using namespace std;class Point{public:static int number;public:Point(){number++;}~Point(){number--;}};int Point::number=0;void main(){Point *ptr;Point A,B;{Point* ptr_point=new Point[3];ptr=ptr_point;}Point C;cout<<Point::number<<endl;delete[] ptr;}运行时输出的结果是(    )。", "options": ["6", "4", "7", "3"], "answer": "A", "explanation": "输出结果为6：1) A,B创建：number=2；2) new Point[3]创建3个对象：number=5；3) C创建：number=6；4) delete[]删除3个对象：number=3。但cout在delete之前执行，输出6。注意：ptr_point局部指针离开作用域，但对象未销毁。", "knowledge_point": "静态成员与对象计数", "difficulty": "hard"}
{"id": 89, "type": "single_choice", "question": "下列关于常成员的说法不正确的是哪一个.", "options": ["常成员函数不可以被非常对象调用", "常数据成员通过构造函数的成员初始列表进行初始化", "常数据成员必须进行初始化，并且不能被更新", "常数据成员可以在定义时直接初始化(C++11)"], "answer": "A", "explanation": "A选项错误：常成员函数可以被非常对象调用，只是不能修改对象的数据成员。常对象只能调用常成员函数。其他选项都正确描述了常成员的特性。", "knowledge_point": "常成员函数与常对象", "difficulty": "medium"}
{"id": 90, "type": "single_choice", "question": "以下关于预处理的说法，错误的是(   )", "options": ["预处理在编译前进行", "预处理指令需要分号结尾", "预处理指令可以出现在程序的任何位置", "每条预处理指令必须单独占用一行"], "answer": "B", "explanation": "B选项错误：预处理指令不需要分号结尾。其他选项正确：预处理在编译前处理；指令可以出现在任何位置（通常放开头）；通常每条指令占一行（可以用\\续行）。", "knowledge_point": "预处理指令语法", "difficulty": "easy"}
{"id": 91, "type": "single_choice", "question": "以下关于外部变量和外部函数的说法，错误的是(   ).", "options": ["静态变量和静态函数即使使用extern声明，它们的使用范围仍然被限定在定义文件中", "外部变量的声明可以是引用性的声明", "外部变量可以为多个源文件所共享", "外部函数和外部变量在声明时，都不能省略关键词extern"], "answer": "D", "explanation": "D选项错误：外部函数在声明时可以省略extern（默认为extern）。外部变量声明通常需要extern（除非是定义）。其他选项都正确。", "knowledge_point": "外部变量与函数", "difficulty": "hard"}
{"id": 92, "type": "single_choice", "question": "有如下程序：#include<iostream>using namespace std;class MyClass{public:MyClass(int x):val(x){}void Set(int x){val=x;}void Print()const{cout<<\"val=\"<<val<<'\\t';}private:int val;};int main(){const MyClass obj1(10);MyClass obj2(20);obj1.Print();      //语句1obj2.Print();      //语句2obj1.Set(20);     //语句3obj2.Set(30);     //语句4return 0;}其主函数中错误的语句是(   )。", "options": ["语句3", "语句2", "语句4", "语句1"], "answer": "A", "explanation": "语句3错误：obj1是const对象，不能调用非const成员函数Set()。Set()函数不是const的，会修改对象状态。其他语句都正确：Print()是const成员函数，可以被const和非const对象调用。", "knowledge_point": "const对象与成员函数", "difficulty": "medium"}
{"id": 93, "type": "single_choice", "question": "有如下类定义：class AA{int a;public:int getRef()const{ return &a;}   //①int getValue()const{ return a; } //②void set(int n)const{a=n;}        //③friend void show(AA aa)const{cout<<a;}  //④};其中的四个函数定义中正确的是(    )。", "options": ["③", "②", "①", "④"], "answer": "B", "explanation": "B选项正确：②是合法的const成员函数，返回a的值。①错误：返回&a但函数是const，应返回const int*；③错误：const成员函数不能修改数据成员a；④错误：友元函数不能是const的。", "knowledge_point": "const成员函数限制", "difficulty": "hard"}
{"id": 94, "type": "single_choice", "question": "如果类A被声明成类B的友元，则( )", "options": ["类A的成员函数不得访问类B的成员", "类A的成员即类B的成员", "类B的成员即类A的成员", "类B不一定是类A的友元"], "answer": "D", "explanation": "D选项正确：友元关系是单向的，A是B的友元，不意味着B是A的友元。A错误：A的成员函数可以访问B的私有成员；B、C错误：友元不改变类成员的归属。", "knowledge_point": "友元关系特性", "difficulty": "easy"}
{"id": 95, "type": "single_choice", "question": "对于常成员函数，下面说法正确的是（ ）。", "options": ["常成员函数只能修改一般数据成员", "常成员函数只能修改常数据成员", "常成员函数不能修改任何数据成员", "常成员函数只能通过对象调用"], "answer": "C", "explanation": "C选项正确：const成员函数不能修改类的任何数据成员（除非成员被mutable修饰）。可以通过对象或const对象调用。", "knowledge_point": "常成员函数限制", "difficulty": "medium"}
{"id": 96, "type": "single_choice", "question": "关于友元，下列说法错误的是( )", "options": ["友元关系不能被继承", "如果类A是类B的友元，那么类A的所有成员函数都是类B的友元", "如果函数fun()被说明为类A的友元，那么在fun()中可以通过Ar的对象访问类A的私有成员", "如果类A是类B的友元，那么类B也是类A的友元"], "answer": "D", "explanation": "D选项错误：友元关系是单向的，不是双向的。其他选项都正确描述了友元的特性：A正确：友元不继承；B正确：友元类的所有成员函数都是友元；C正确：友元函数可以访问私有成员。", "knowledge_point": "友元关系", "difficulty": "easy"}
{"id": 97, "type": "single_choice", "question": "下面关于友元的描述中，错误的是(   )", "options": ["友元可以提高程序的运行效率", "若A是B的友元类,则B类可以访问A类的私有成员", "友元函数通过该类的对象可以访问该类的私有数据成员", "一个类的友元类中的成员函数都是这个类的友元函数"], "answer": "B", "explanation": "B选项错误：A是B的友元，意味着A可以访问B的私有成员，而不是B可以访问A的私有成员。友元关系是单向的。其他选项都正确。", "knowledge_point": "友元类特性", "difficulty": "medium"}
{"id": 98, "type": "single_choice", "question": "执行下列程序语句后，屏幕输出为（    ）。#include<iostream>using namespace std;int n=5;int main(){int n=3;n++;::n++;cout<<n<<endl;return 0;}", "options": ["4", "6", "3", "5"], "answer": "A", "explanation": "输出结果为4：1) 局部n=3；2) n++使局部n=4；3) ::n++使全局n=6；4) cout<<n输出局部n=4。注意：::n访问全局变量。", "knowledge_point": "作用域运算符", "difficulty": "easy"}
{"id": 99, "type": "single_choice", "question": "若有以下类Z说明，函数fStatic中访问数据a错误的是( )。class Z{static int a;public:static void fStatic();};int Z::a = 0 ;Z objZ ;", "options": ["void Z::fStatic(){ Z::a = 0 ; }", "void Z::fStatic(){ this->a = 0 ; }", "void Z::fStatic(){ a = 1; }", "void Z::fStatic(){ Z::a = 1; }"], "answer": "B", "explanation": "B选项错误：fStatic是静态成员函数，没有this指针，不能使用this->。其他选项都能正确访问静态成员a（通过类名或直接访问）。", "knowledge_point": "静态成员函数与this指针", "difficulty": "medium"}
{"id": 100, "type": "single_choice", "question": "对于友元函数描述正确的是（ ）", "options": ["友元函数不能访问本类私有成员", "友元函数不是本类的成员函数", "友元函数不是函数", "友元函数是本类的成员函数"], "answer": "B", "explanation": "B选项正确：友元函数不是类的成员函数，是普通函数或另一个类的成员函数，被授予访问该类私有成员的权限。A错误：友元函数可以访问私有成员；C错误：友元函数是函数；D错误：不是成员函数。", "knowledge_point": "友元函数本质", "difficulty": "easy"}
{"id": 101, "type": "single_choice", "question": "下列关于运算符重载的描述中，正确的是( )。", "options": ["一元运算符只能作为成员函数重载", "运算符重载为成员函数时，若参数表中无参数，重载的是一元运算符", "C++中可以重载所有的运算符", "二元运算符重载为非成员函数时，参数表中有一个参数"], "answer": "B", "explanation": "B选项正确：成员函数重载运算符时，参数个数比实际操作数少1（隐含this）。一元运算符作为成员函数时参数表为空。A错误：一元运算符也可作为友元函数重载；C错误：有些运算符不能重载（如::、.、.*、?:等）；D错误：二元运算符作为非成员函数时应有两个参数。", "knowledge_point": "运算符重载规则", "difficulty": "medium"}
{"id": 102, "type": "single_choice", "question": "下列运算符中，不能被重载的是( )。", "options": ["++", "!=", "&&", "."], "answer": "D", "explanation": "D选项正确：成员访问运算符.不能重载。其他运算符都可以重载。不能重载的运算符还有：作用域解析运算符::、成员指针运算符.*、条件运算符?:、sizeof运算符等。", "knowledge_point": "不可重载运算符", "difficulty": "easy"}
{"id": 103, "type": "single_choice", "question": "下面是重载为非成员函数的运算符函数原型，其中错误的是( )。", "options": ["Fraction& operator+=(Fraction&,Fraction);", "Fraction& operator=(Fraction& ,Fraction);", "Fraction operator+(Fraction,Fraction);", "Fraction operator-(Fraction);"], "answer": "B", "explanation": "B选项错误：赋值运算符=只能作为成员函数重载，不能作为非成员函数（友元函数）重载。其他运算符可以作为非成员函数重载。", "knowledge_point": "运算符重载形式限制", "difficulty": "hard"}
{"id": 104, "type": "single_choice", "question": "下面程序中对一维坐标点类Point进行运算符重载#include <iostream>using namespace std;class Point{public:Point(int val) {x=val;}Point& operator ++(){x++;return *this;}Point operator ++(int) {Point old=*this;++(*this);return old;}int GetX() const {return x;}private:int x;};int main(){Point a(10);cout<<(++a).GetX();cout<<a++.GetX();return 0;}编译和运行情况是(    )。", "options": ["运行时输出 1111", "编译有错", "运行时输出 1011", "运行时输出 1112"], "answer": "A", "explanation": "输出结果为1111：1) (++a)前缀++，a.x从10变为11，输出11；2) a++后缀++，先返回旧值（11），然后a.x变为12，输出11。所以输出1111（实际是11和11，中间无空格）。", "knowledge_point": "自增运算符重载", "difficulty": "hard"}
{"id": 105, "type": "single_choice", "question": "在一个抽象类中，一定包含有( )。", "options": ["模板函数", "重载函数", "虚函数", "纯虚函数"], "answer": "D", "explanation": "D选项正确：抽象类是包含至少一个纯虚函数的类。不一定包含模板函数、重载函数或普通虚函数，但必须至少有一个纯虚函数。", "knowledge_point": "抽象类定义", "difficulty": "easy"}
{"id": 106, "type": "single_choice", "question": "#include<iostream>using namespace std;class Complex{public:Complex(double r=0,double i=0):re(r),im(i){}double real() const { return re; }double imag() const { return im; }Complex operator+(Complex c)const{ return Complex(re+c.re,im+c.im); }private:double re,im;};int main(){Complex a=Complex(1,1)+Complex(5);cout<<a.real()<<'+'<<a.imag()<<'i'<<endl;return 0;}程序执行后的输出结果是（    ）。", "options": ["1+1i", "6+6i", "1+6i", "6+1i"], "answer": "D", "explanation": "输出结果为6+1i：Complex(1,1)实部1虚部1，Complex(5)等价于Complex(5,0)实部5虚部0。相加得实部6虚部1，所以输出6+1i。", "knowledge_point": "复数类运算符重载", "difficulty": "medium"}
{"id": 107, "type": "single_choice", "question": "在表达式x+y*z中，+是作为成员函数重载的运算符，*是作为非成员函数重载的运算符。下列叙述中正确的是( )。", "options": ["operator+有两个参数，operator*有两个参数", "operator+有一个参数，operator*有一个参数", "operator+有两个参数，operator*有一个参数", "operator+有一个参数，operator*有两个参数"], "answer": "D", "explanation": "D选项正确：+作为成员函数重载时有一个参数（另一个是this），*作为非成员函数重载时有两个参数。注意：表达式x+y*z等价于x.operator+(y.operator*(z))或x.operator+(operator*(y,z))。", "knowledge_point": "运算符重载参数个数", "difficulty": "hard"}
{"id": 108, "type": "single_choice", "question": "已知Value是一个类，value是Value的一个对象。下列以非成员函数形式重载的运算符函数原型中，正确的是( )。", "options": ["Value operator+(Value v,int i=0);", "Value operator+(Value v,int i);", "Value operator+(Value v=value,int i=0);", "Value operator+(Value v=value,int i);"], "answer": "B", "explanation": "B选项正确：非成员函数重载运算符时，函数原型应包含所需的参数，不能有默认对象参数。A错误：可以有默认参数但通常不这样用；C、D错误：函数参数不能有默认对象（value）。", "knowledge_point": "运算符重载函数原型", "difficulty": "medium"}
{"id": 109, "type": "single_choice", "question": "有如下程序#include<iostream>using namespace std;class A{public:virtual void func1(){cout<<\"Al\";}void func2(){cout<<\"A2\";}};class B:public A{public:void func1(){cout<<\"B1\";}void func2(){cout<<\"B2\";}};int main(){A*p=new B;p->func1();p->func2();return 0;}运行此程序，屏幕上将显示输出(    )。", "options": ["A1A2", "B1B2", "B1A2", "A1B2"], "answer": "C", "explanation": "输出结果为B1A2：1) p->func1()调用虚函数，多态调用B::func1()，输出B1；2) p->func2()调用非虚函数，静态绑定A::func2()，输出A2。", "knowledge_point": "虚函数与非虚函数区别", "difficulty": "medium"}
{"id": 110, "type": "single_choice", "question": "在表达式x-y中，\"-\"是作为非成员函数重载的运算符。若使用显式的函数调用代替直接使用运算符\"-\"，这个表达式还可以表示为（ ）。", "options": ["operator -(y,x)", "x.operator -(y)", "y.operator -(x)", "operator -(x,y)"], "answer": "D", "explanation": "D选项正确：非成员函数重载的运算符调用形式为operator-(x,y)，参数顺序与表达式一致（x-y）。如果是成员函数重载，则为x.operator-(y)。", "knowledge_point": "运算符显式调用", "difficulty": "medium"}
{"id": 111, "type": "single_choice", "question": "已知在一个类体中包含如下函数原型：VOLUME operator-(VOLUME)const;，下列关于这个函数的叙述中，错误的是( )。", "options": ["这是运算符-的重载运算符函数", "这个函数不改变类的任何数据成员的值", "这个函数所重载的运算符是一个一元运算符", "这是一个成员函数"], "answer": "C", "explanation": "C选项错误：作为成员函数，operator-(VOLUME)有一个参数，加上隐含的this，总共两个参数，所以是二元运算符（如a-b）。如果是一元运算符，作为成员函数应该没有参数（如-a）。", "knowledge_point": "运算符重载参数分析", "difficulty": "hard"}
{"id": 112, "type": "single_choice", "question": "下列选项中，与实现运行时多态性无关的是( ）。", "options": ["指针", "重载函数", "虚函数", "引用"], "answer": "B", "explanation": "B选项正确：函数重载是编译时多态（静态多态）。运行时多态（动态多态）通过虚函数实现，通常使用指针或引用来调用。", "knowledge_point": "多态类型", "difficulty": "easy"}
{"id": 113, "type": "single_choice", "question": "下列有关继承和派生的叙述中，正确的是( )。", "options": ["如果派生类没有实现基类的一个纯虚函数，则该派生类是一个抽象类", "如果一个派生类私有继承其基类，则该派生类中的成员不能访问基类的保护成员", "基类对象可以赋值给派生类对象", "派生类的成员函数可以访问基类的所有成员"], "answer": "A", "explanation": "A选项正确：派生类必须实现所有纯虚函数才能成为具体类，否则仍是抽象类。B错误：私有继承下，派生类成员可以访问基类的保护成员；C错误：派生类对象可以赋值给基类对象（切片），反之不行；D错误：不能访问基类私有成员。", "knowledge_point": "继承基本概念", "difficulty": "medium"}
{"id": 114, "type": "single_choice", "question": "有如下的运算符重载函数定义： double operator +(int i,int k){return double(i+k);} 但定义有错误，对这个错误最准确的描述是( )。", "options": ["C++已经提供了求两个int型数据之和的运算符+，不能再定义同样的运算符", "两个int型参数的和也应该是int型，而这里将+的返回类型声明为double", "没有将运算符重载函数声明为某个类的友元", "+只能作为成员函数重载，而这里的+是作为非成员函数重载的"], "answer": "A", "explanation": "A选项正确：运算符重载必须至少有一个参数是类类型或枚举类型，不能为内置类型重载运算符。这里两个参数都是int（内置类型），所以错误。", "knowledge_point": "运算符重载限制", "difficulty": "hard"}
{"id": 115, "type": "single_choice", "question": "所谓多态性是指 （ ）", "options": ["一个对象调用不同名称的对象", "不同的对象调用不同名称的函数", "不同的对象调用相同名称的函数", "一个对象调用不同名称的函数"], "answer": "C", "explanation": "C选项正确：多态性指相同的函数名在不同的对象上有不同的实现。包括编译时多态（函数重载、模板）和运行时多态（虚函数）。", "knowledge_point": "多态性定义", "difficulty": "easy"}
{"id": 116, "type": "single_choice", "question": "运算符重载是对已有的运算符赋予多重含义，因此（ ）。", "options": ["可以对基本类型（如int类型）的数据，重新定义\"+\"运算符的含义", "可以改变一个已有运算符的优先级和操作数个数", "只能重载C++中己经有的运算符，不能定义新运算符", "C++中已经有的所有运算符都可以重载"], "answer": "C", "explanation": "C选项正确：只能重载C++已有的运算符，不能创建新运算符（如@、$等）。A错误：不能为内置类型重载运算符；B错误：不能改变优先级和操作数个数；D错误：有些运算符不能重载。", "knowledge_point": "运算符重载限制", "difficulty": "medium"}
{"id": 117, "type": "single_choice", "question": "关于虚函数，下列表述正确的是（ ）。", "options": ["虚函数不能声明为静态函数", "如果在重定义虚函数时使用了保留字virtual，则该重定义函数仍然是虚函数", "派生类必须重新定义基类的虚函数", "虚函数不得声明为另一个类的友元函数"], "answer": "A", "explanation": "A选项正确：虚函数不能是static的，因为static函数属于类而不是对象，没有this指针。B正确但非最佳（virtual可省略）；C错误：派生类可以不重写虚函数；D错误：虚函数可以是友元函数。", "knowledge_point": "虚函数特性", "difficulty": "medium"}
{"id": 118, "type": "single_choice", "question": "关于虚函数的描述中，正确的是( )。", "options": ["虚函数是一个非成员函数", "派生类的虚函数与基类的虚函数具有不同的参数个数和类型", "虚函数是一个static类型的成员函数", "基类中说明了虚函数后，派生类中将其对应的函数可不必说明为虚函数"], "answer": "D", "explanation": "D选项正确：派生类中重写虚函数时，virtual关键字可省略（自动成为虚函数）。A错误：虚函数必须是成员函数；B错误：函数签名必须相同（协变返回类型除外）；C错误：虚函数不能是static的。", "knowledge_point": "虚函数重写", "difficulty": "medium"}
{"id": 119, "type": "single_choice", "question": "下列是重载乘法运算符的函数原型声明，其中错误的是( )。", "options": ["MyClass operator * (MyClass,double);", "MyClass operator * (MyClass,MyClass);", "MyClass operator * (double,MyClass);", "MyClass operator * (double,double);"], "answer": "D", "explanation": "D选项错误：两个参数都是内置类型double，没有类类型参数，不符合运算符重载规则（必须至少有一个类类型参数）。其他选项都至少有一个MyClass类型参数。", "knowledge_point": "运算符重载参数要求", "difficulty": "hard"}
{"id": 120, "type": "single_choice", "question": "下列有关运算符重载的叙述中，正确的是( )。", "options": ["重载运算符时可以改变其结合性", "C++中所有运算符都可以作为非成员函数重载", "C++中可以通过运算符重载创造新的运算符", "运算符重载是多态性的一种表现"], "answer": "D", "explanation": "D选项正确：运算符重载是编译时多态（静态多态）的一种形式。A错误：不能改变结合性；B错误：有些运算符只能作为成员函数重载（如=、[]、()、->）；C错误：不能创造新运算符。", "knowledge_point": "运算符重载与多态", "difficulty": "medium"}
{"id": 121, "type": "single_choice", "question": "C++流中重载的运算符>>是一个（ ）。", "options": ["用于输入操作的成员函数", "用于输出操作的非成员函数", "用于输出操作的成员函数", "用于输入操作的非成员函数"], "answer": "D", "explanation": "D选项正确：>>是流提取运算符，用于输入操作，在C++标准库中重载为全局函数（非成员函数），如istream& operator>>(istream&, type&)。", "knowledge_point": "流运算符重载", "difficulty": "medium"}
{"id": 122, "type": "single_choice", "question": "在C++中，用于实现运行时多态性的是（ ）。", "options": ["重载函数", "模板函数", "内联函数", "虚函数"], "answer": "D", "explanation": "D选项正确：运行时多态（动态多态）通过虚函数和继承实现。重载函数和模板函数是编译时多态，内联函数是优化机制。", "knowledge_point": "运行时多态实现", "difficulty": "easy"}
{"id": 123, "type": "single_choice", "question": "虚函数的（ ）可以不同。", "options": ["函数名", "参数个数", "函数体内容", "返回类型"], "answer": "C", "explanation": "C选项正确：虚函数重写时，函数体内容（实现）可以不同，这是多态的核心。函数名、参数个数和类型必须相同（协变返回类型除外）。", "knowledge_point": "虚函数重写要求", "difficulty": "easy"}
{"id": 124, "type": "single_choice", "question": "在具有继承关系的类层次体系中,析构函数执行的顺序是 （　　　　）。", "options": ["对象成员析构函数-基类析构函数-派生类本身的析构函数", "派生类本身的析构函数-对象成员析构函数-基类析构函数", "基类析构函数-派生类本身的析构函数-对象成员析构函数", "基类析构函数-对象成员析构函数-派生类本身的析构函数"], "answer": "B", "explanation": "B选项正确：析构顺序与构造顺序相反：1) 派生类析构函数；2) 派生类对象成员析构函数（按声明逆序）；3) 基类析构函数（按继承逆序）。", "knowledge_point": "析构函数调用顺序", "difficulty": "medium"}
{"id": 125, "type": "single_choice", "question": "如果从原有类定义新类可以实现的是（ ）", "options": ["信息隐藏", "数据抽象", "继承机制", "数据封装"], "answer": "C", "explanation": "C选项正确：继承机制允许从已有类派生新类。信息隐藏、数据抽象、数据封装是面向对象的基本特性，但不特指从原有类定义新类。", "knowledge_point": "继承概念", "difficulty": "easy"}
{"id": 126, "type": "single_choice", "question": "在C++中,不加说明,则默认的继承方式是（　　　　） 。", "options": ["protected", "private", "public或protected", "public"], "answer": "B", "explanation": "B选项正确：class定义的类默认继承方式是private，struct定义的类默认继承方式是public。题目中应该是class的情况。", "knowledge_point": "默认继承方式", "difficulty": "easy"}
{"id": 127, "type": "single_choice", "question": "对于通过公有继承定义的派生类，若其成员函数可以直接访问基类的某个成员，说明该基类成员的访问权限是( )。", "options": ["保护或私有", "私有", "公有或私有", "公有或保护"], "answer": "D", "explanation": "D选项正确：公有继承下，派生类成员函数可以访问基类的public和protected成员，不能访问private成员。所以可访问的成员权限是public或protected。", "knowledge_point": "继承访问权限", "difficulty": "medium"}
{"id": 128, "type": "single_choice", "question": "在公有派生的情况下，派生类中定义的成员函数只能访问原基类的( )", "options": ["公有成员和保护成员", "私有成员和保护成员", "私有成员、保护成员和公有成员", "公有成员和私有成员"], "answer": "A", "explanation": "A选项正确：公有继承下，派生类成员函数可以访问基类的public和protected成员，不能访问private成员。这是继承访问控制的基本规则。", "knowledge_point": "公有继承访问权限", "difficulty": "easy"}
{"id": 129, "type": "single_choice", "question": "在多重继承中,为了避免派生类中访问公共基类公有属性多份拷贝的二义性。可以将一个类声明为(     )。", "options": ["派生类", "虚基类", "友元类", "抽象类"], "answer": "B", "explanation": "B选项正确：虚基类用于解决菱形继承中的二义性和数据冗余问题。通过虚继承，派生类只包含一个共享的基类子对象。", "knowledge_point": "虚基类作用", "difficulty": "medium"}
{"id": 130, "type": "single_choice", "question": "一个类可以同时继承多个类，称为多继承。下列关于多继承和虚基类的表述中，错误的是( )。", "options": ["每个派生类的构造函数都要为虚基类构造函数提供实参", "建立最远派生类对象时，虚基类的构造函数会首先被调用", "使用虚基类可以解决二义性问题并实现运行时的多态性", "多继承时有可能出现对基类成员访问的二义性问题"], "answer": "C", "explanation": "C选项错误：虚基类解决二义性和数据冗余问题，但与运行时多态性无关。运行时多态通过虚函数实现。其他选项都正确描述了虚基类的特性。", "knowledge_point": "虚基类与多态", "difficulty": "hard"}
{"id": 131, "type": "single_choice", "question": "派生类的成员函数不能直接访问基类的( )。", "options": ["公有成员", "公有成员和保护成员", "私有成员", "保护成员"], "answer": "C", "explanation": "C选项正确：无论何种继承方式，派生类成员函数都不能直接访问基类的private成员。只能通过基类提供的public或protected接口间接访问。", "knowledge_point": "基类私有成员访问", "difficulty": "easy"}
{"id": 132, "type": "single_choice", "question": "在一个派生类的成员函数中，试图调用其基类的成员函数\"void f();\"，但无法通过编译。这说明( )。", "options": ["f()是基类的私有成员", "派生类的继承方式为私有", "派生类的继承方式为保护", "f()是基类的保护成员"], "answer": "A", "explanation": "A选项正确：如果f()是public或protected，派生类成员函数可以访问。编译错误最可能的原因是f()是private成员。继承方式不影响派生类对基类成员的访问（只影响外部访问）。", "knowledge_point": "基类成员访问权限", "difficulty": "medium"}
